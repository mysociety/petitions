#!/usr/bin/php -q
<?php
/* 
 * send-messages
 * Run from cron regularly to send out Government responses to petitions
 * so forth, and take appropriate action.
 *
 * Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
 * Email: matthew@mysociety.org. WWW: http://www.mysociety.org/
 *
 * $Id: send-messages,v 1.39 2007-04-18 09:47:15 keith Exp $
 *
 */

$short_opts = '';
$long_opts = array('verbose','help');

# XXX: Roll-on doing it in code!
# trident, IDcards, traveltax, CensusInfoFreed, Photography, SaveTheReds, DC-Stephen-Oake, SirBobPaisley, wimbledon
$separate_mailout_petitions = " and (message.petition_id not in (97,138,27794,161913,2579595,1063764,568,124420,2786467))";

chdir(dirname($_SERVER['SCRIPT_FILENAME']));
require_once '../conf/general';
require_once "../phplib/petcli.php";
require_once '../phplib/petition.php';
require_once '../phplib/token.php';
require_once "../phplib/fns.php";

function verbose($str) {
    global $verbose;
    if ($verbose) 
        fwrite(STDERR, "send-messages: $str\n");
}
function error($str) {
    fwrite(STDERR, "send-messages: ERROR: $str\n");
}

$switches = $options[0];
$args = $options[1];
$verbose = 0; 
foreach ($switches as $switch) {
    if ($switch[0]=='--verbose') $verbose = 1;
    if ($switch[0]=='--help') {
?>

No10 Petitions message sending script. This is responsible for sending
out government responses to petitions and so forth. It should be run
periodically from cron.

Usage: send-messages [--verbose]

--help      Display this help message
--verbose   Display more information

<?
        exit;
    }
}

db_connect();
send_pending_messages();

# ---

/* send_pending_messages
 * Dispatch messages to petition signers and creators which have not yet been
 * sent. */
function send_pending_messages() {
    global $separate_mailout_petitions;

    /* Messages to the administrators. */
    verbose("sending pending admin messages");
    
    $q = db_query("
                select * from message
                where sendtoadmin
                    and (select message_id
                        from message_admin_recipient
                        where message_id = id) is null
                    $separate_mailout_petitions
                order by random()");

    while ($msg = db_fetch_array($q)) {
        db_query("lock table message_admin_recipient in exclusive mode");
        $f = db_getOne('
                    select message_id
                    from message_admin_recipient
                    where message_id = ?
                    for update', $msg['id']);
        
        if (!is_null($f)) {
            verbose("message #${msg['id']} sent while waiting for lock; skipping");
            continue;
        }

        $petition = new Petition(intval($msg['petition_id']));
        $data = $petition->data;
        $data['url'] = OPTION_ADMIN_URL . '?page=pet&petition=' . $data['ref'];
        $data['comments_blurb'] = '';
        if ($data['comments'])
                $data['comments_blurb'] = "The creator added the following comments for you:\n" . $data['comments'] . "\n\n-----\n\n";

        verbose("message #${msg['id']} is for petition #" . $petition->id() . " (" . $petition->ref() . "); circumstance '${msg['circumstance']}'");
        
        $f = false;
        $headers = array();
        if (isset($msg['emailtemplatename'])) {
            verbose("sending message #${msg['id']} using email template '${msg['emailtemplatename']}'");
            $f = pet_send_email_template(OPTION_CONTACT_EMAIL, $msg['emailtemplatename'], $data, $headers);
        } else {
            verbose("sending message #${msg['id']} as raw email, subject '${msg['emailsubject']}'");
            $f = pet_send_email(OPTION_CONTACT_EMAIL, $msg['emailsubject'], $msg['emailbody'], $headers);
        }

        if ($f)
            db_query('
                    insert into message_admin_recipient (message_id)
                    values (?)', $msg['id']);
        else
            error("failed to send message #${msg['id']} to admins");

        db_commit();
    }

    /* Messages to creators. */
    verbose("sending pending creator messages");
    
    $q = db_query("
                select * from message
                where sendtocreator
                    and (select message_id
                        from message_creator_recipient
                        where message_id = id
                            and message_creator_recipient.petition_id
                                = message.petition_id) is null
                    $separate_mailout_petitions
                order by random()");

    while ($msg = db_fetch_array($q)) {
        /* Grab lock. As ever, this is bloody ugly, because we have to do
         * something (send an email) which isn't transactional in the
         * database, so we must do only one thing per transaction and commit
         * once that transaction has succeeded. */
        db_query("lock table message_creator_recipient in exclusive mode");
        $f = db_getOne('
                    select message_id
                    from message_creator_recipient
                    where message_id = ?
                    for update', $msg['id']);

        if (!is_null($f)) {
            verbose("message #${msg['id']} sent while waiting for lock; skipping");
            continue;
        }

        $petition = new Petition(intval($msg['petition_id']));
        $data = $petition->data;
        verbose("message #${msg['id']} is for petition #" . $petition->id() . " (" . $petition->ref() . "); circumstance '${msg['circumstance']}'");

        /* XXX we also need a URL containing a token which is sent on
         * success to the signer. For now just generate this here, but
         * later on we'll need to move it into message, so that we can send
         * reminders. */
        /* XXX Not using creator messages yet */
        if ($msg['circumstance'] == 'announce-post') {
            $announce_url = $petition->url_announce();
            $params = array();
            $data['url'] = pb_person_make_signon_url(null, $petition->creator_email(), 
                "GET", $petition->url_announce(), $params);
        } elseif ($msg['circumstance'] == 'rejected-once') {
            $data['url'] = OPTION_BASE_URL . '/' . $petition->ref() . '/' . token_make('e', $petition->id());
        } elseif ($msg['circumstance'] == 'approved') {
            $data['url'] = OPTION_BASE_URL . '/' . $petition->ref() . '/';
        } elseif ($msg['circumstance'] == 'rejected-timeout') {
            if (!$petition->rejected_show_part('ref')) {
                $data['url'] = OPTION_BASE_URL . '/reject?id=' . $petition->id();
            } else {
                $data['url'] = OPTION_BASE_URL . '/' . $petition->ref() . '/';
            }
        }
        if ($msg['circumstance'] == 'rejected-once' || $msg['circumstance'] == 'rejected-again'
            || $msg['circumstance'] == 'rejected-timeout') {
            if ($data['rejection_reason'])
                $data['rejection_reason'] = "\nFurther information: " . $data['rejection_reason'];
        }

        // Case when it is a copy sent to creator
        if ($msg['sendtosigners'] == 't' && in_array($msg['circumstance'], array('general-announce') )) {
            $msg['emailbody'] = sprintf(_("[ This is a copy of the message you have just sent to everyone who signed your petition %s ]\n\n%s"), $petition->url_main(), $msg['emailbody']);
        }

        // Make any extra headers
        $headers = array();

        // Send with template or raw appropriately
        $f = false;
        if (isset($msg['emailtemplatename']))
        {
            verbose("sending message #${msg['id']} using email template '${msg['emailtemplatename']}'");
            $f = pet_send_email_template($petition->creator_email(), $msg['emailtemplatename'], $data, $headers);
        }
        else
        {
            // We assume that this is now a government response
            $subject = "";

            if ($msg['fromaddress'] == 'number10html')
            {
                $type = 'email';
            }
            else
            {   
                $type = 'plain';
                $subject = "Subject: " . $msg['emailsubject'] . "\n";
            }

            $descriptorspec = array(
                0 => array('pipe', 'r'), 
                1 => array('pipe', 'w'),
            );
            $result = proc_open("./create-preview $type $msg[petition_id]", $descriptorspec, $pipes);

            fwrite($pipes[0], $msg['emailsubject']);
            fwrite($pipes[0], "\n\n");
            fwrite($pipes[0], $msg['emailbody']);
            fclose($pipes[0]);
            $out = '';
            while (!feof($pipes[1]))
            {
                $out .= fread($pipes[1], 8192);
            }
            fclose($pipes[1]);
            proc_close($result);

            verbose("sending message #${msg['id']} as raw $type to evel_send, subject '${msg['emailsubject']}'");

            # Doing this manually since this will be the only case where it happens.
            # All other HTML email cases are shifted by the response-send script which
            # goes direct to exim instead of through EvEl.

            $date = "Date: " . date("r") . "\n";
            $from = "From: " . OPTION_GENERAL_SEND_NAME . "<" . OPTION_GENERAL_SEND_EMAIL . ">\n";
            $to = "To: " . $petition->creator_email() . "\n";
            $precedence = "Precedence: bulk\n";

            $out = $from . $to . $date . $precedence . $subject . $out;
            $f = evel_send($out, $petition->creator_email());
        }

        // Store success
        if ($f)
            db_query('
                    insert into message_creator_recipient
                        (message_id, petition_id)
                    values (?, ?)', array($msg['id'], $petition->id()));
        else
            error("failed to send message #${msg['id']} to creator of petition #" . $petition->id() . " (" . $petition->ref() . ")");

        db_commit();
    }

    /* Messages to signers. We grab message and recipient
     * info for each signer-message pair which is pending on delivery. */
    verbose("sending pending signer messages");
     
    $q = db_query("
                select message.*,
                    signer.id as signer_id,
                    signer.name as signer_name,
                    signer.email as signer_email,
                    extract(epoch from signer.signtime)
                        - extract(epoch from message.whencreated) as howlongago,
                    petition.ref,
                    petition.id as petition_id
                from message, petition, signer
                where sendtosigners
                and emailtemplatename !='' 
                    and message.petition_id = signer.petition_id
                    and message.petition_id = petition.id
                    and sendtolatesigners = 'f'
                    and signer.signtime < message.whencreated
                    and (select signer_id
                        from message_signer_recipient
                        where message_id = message.id
                            and signer_id = signer.id) is null
                    and signer.emailsent = 'confirmed'
                    and signer.showname = 't'
                    and lower(signer.email) not in (select lower(email) from optout)
                    $separate_mailout_petitions
                order by whencreated desc");
        # XXX: Should optout be done like this?

        /* XXX ugly. For a raw email we will transmit the (possibly large)
         * body of the mail over the wire once for each row. Should do a
         * subquery for it and cache the result. */

    while ($r = db_fetch_array($q)) {
        /* Grab a lock. */
        db_query("lock table message_signer_recipient in exclusive mode");
        db_getOne('select id from signer where id = ? for update', $r['id']);

        /* Check that the message hasn't already been sent. */
        $f = db_getOne('
                    select message_id
                    from message_signer_recipient
                    where message_id = ? and signer_id = ?',
                    array($r['id'], $r['signer_id']));

        if (!is_null($f)) {
            verbose("message #${r['id']} sent to signer #${r['signer_id']} while waiting for lock; skipping");
            continue;
        }

        verbose("message #${r['id']} to be sent to signer #${r['signer_id']}");

        // Make any extra headers
        $petition = new Petition($r['ref']);

        $headers = array();
        if ($r['fromaddress'] == 'number10' || $r['fromaddress'] == 'number10html') {
            // the default in pet_send_email_internal is from Number10
        } else {
            error("Unknown 'from' in message " . $r['id'] . ": " . $msg['fromaddress']);
        }

        $data = $petition->data;
        verbose("sending message #${r['id']} using email template '${r['emailtemplatename']}'");
        $f = pet_send_email_template($r['signer_email'], $r['emailtemplatename'], $data, $headers);

        if ($f) {
            db_query('
                insert into message_signer_recipient (message_id, signer_id)
                values (?, ?)', array($r['id'], $r['signer_id']));
        } else
            error("failed to send message #${r['id']} to signer #${r['signer_id']} of petition #${r['petition_id']}");

        db_commit();
    }
}

