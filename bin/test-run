#!/usr/bin/perl -w -I../../perllib
#
# test-run:
# Test harness for petitions.  Makes sure we haven't broken the code.
# 
# Requires:
# * ../general/conf file set up for petitions, and matching the below requirements
# * apache configured to serve ../web on OPTION_BASE_URL
# * a petitions database with name ending "_testharness"; this script will drop and remake 
#   the database, so make sure it is never used for anything important
# * email addresses (email_n below) configured to pipe to ./test-mailin with fast
#   local delivery, and
#
# Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

my $rcsid = ''; $rcsid .= '$Id: test-run,v 1.9 2006-10-06 15:11:51 francis Exp $';

use strict;
require 5.8.0;

use Data::Dumper;
use Carp qw(verbose);
use Storable;
use FindBin;
use Getopt::Long;
use IO::Handle;
use POSIX;

use mySociety::Config;
mySociety::Config::set_file('../conf/general');
use mySociety::DBHandle qw(dbh);
use mySociety::WebTestHarness;

sub help {
print <<END

Usage: test-run [OPTION}

Options are
    --verbose=n   Choose 0 (no progress), 1 (basic actions), 2 (full debug)

END
}

# Parse command line
our $verbose = 0; # currently 3 levels: 0, 1 and 2
our $multispawn = 1; # can test launching multiple instances of cron jobs
our $help;
if (!GetOptions(
        'verbose=i' =>  \$verbose,
        'help' =>               \$help
    )) {
    help();
    exit(1);
}
if ($help) {
    help();
    exit(0);
}

# Set up options

our $base_url = mySociety::Config::get('BASE_URL');
our $admin_url = mySociety::Config::get('ADMIN_URL');
our $auth_user = mySociety::Config::get('AUTH_USER');
our $auth_password = mySociety::Config::get('AUTH_PASSWORD');
our $auth_realm = "ePetitions staging site";
our $httpd_error_log = mySociety::Config::get('HTTPD_ERROR_LOG');
our $email_domain = mySociety::Config::get('EMAIL_DOMAIN');
our $contact_email = mySociety::Config::get('CONTACT_EMAIL');
our $test_email_prefix = mySociety::Config::get('TEST_EMAIL_PREFIX');
sub email_n { my $n = shift; return "$test_email_prefix+$n\@$email_domain"; }
sub name_n { my $n = shift; return "Persephone Petitioner $n"; }

#############################################################################
# Main code

# Configure test harness class
print "Starting daemons...\n" if $verbose > 0;
my $petemaild_pid = fork();
die "failed to fork" if (!defined($petemaild_pid));
if ($petemaild_pid == 0) {
    exec("./petemaild", "--debug");
    exit;
}
END {
    kill(POSIX::SIGHUP, $petemaild_pid);
    while (1) {
        my $wait_pid = wait();
        last if ($wait_pid == -1);
    }
};

print "Set up web test harness...\n" if $verbose > 0;
our $wth = new mySociety::WebTestHarness();
$base_url =~ m#^http://(.+)/?$#;
$wth->browser_credentials("$1:80", $auth_realm, $auth_user, $auth_password);
$wth->log_watcher_setup($httpd_error_log);
$wth->log_watcher_self_test($base_url . "/test.php?error=1", "deliberate_error_to_test_error_handling");
$wth->database_connect('PET_');
$wth->database_drop_reload('../db/schema.sql');
$wth->database_cycle_sequences(200);
my $eveld_bin = "$FindBin::Bin/../../services/EvEl/bin/eveld";
$eveld_bin = undef if ! -e $eveld_bin; # when running on servers rely on EvEl daemon, rather than calling EvEl binary directly XXX need more explicit way of distinguishing this case, than just checking evel isn't checked out in the same tree
$wth->email_setup({ eveld_bin => $eveld_bin,
                    log_mailbox => "log_mailbox" });
$wth->browser_set_validator("/usr/bin/validate");

# Syntax check all .php files
print "Syntax check all PHP files...\n" if $verbose > 0;
$wth->php_check_syntax("../../pet/");
$wth->php_check_syntax("../../pet/templates/emails/", qr//);

print "Basic test...\n" if $verbose > 0;
do_basic_test();

# Check for any unhandled mails or errors
#call_fyrqd();
print "Checking no emails left at end...\n" if $verbose > 1;
$wth->email_check_none_left();
print "Checking no log file errors at end...\n" if $verbose > 1;
$wth->log_watcher_check();
print "Everything completed successfully\n";

#############################################################################
# General functions

# Change the date that all parts of ePetitions think is today.  Call with no
# parameters to reset it to the actual today.
sub set_pet_date {
    my $new_date = shift;
    if (defined($new_date)) {
        dbh()->do('delete from debugdate; insert into debugdate (override_today) values (?);', {}, $new_date);
    } else {
        dbh()->do('delete from debugdate;');
    }
    dbh()->commit();
}

# Call fyrqd for one pass
#sub call_fyrqd {
#    system("./fyrqd", "--debug", "--once", "--email", # $verbose > 1 ? qw(--verbose) : ()
#        ) and die "Failed to call fyrqd";
#}

# Call send messages cron job
sub call_send_messages {
     $wth->multi_spawn($multispawn, "php send-messages " . ($verbose > 1 ? qw(--verbose) : ''), $verbose);
}

# Call mark finished cron job
sub call_mark_finished {
     $wth->multi_spawn($multispawn, "php mark-finished " . ($verbose > 1 ? qw(--verbose) : ''), $verbose);
}

#############################################################################

sub do_basic_test {
    set_pet_date('1988-08-08');

    $wth->browser_get($base_url);
    $wth->browser_check_contents("Petitions");
    $wth->browser_follow_link(text_regex => qr/Create a Petition/);

    $wth->browser_check_contents("Part 1 of 3");
    $wth->browser_submit_form(form_name => 'newpetition',
            fields => {
                pet_content => 'take action on every petition on this site with more than 1000 signers',
                detail => 'I think it is very important that the Prime Minister takes all petitions seriously. He should be compelled to do anything that more than 1000 people sign, as this would be good for democracy and not at all exploitable by small groups of people.',
                rawdeadline => '31st December 1988',
                ref => 'onethousand'
                }, button => 'tostepyou') or die "Failed to submit step 1";

    $wth->browser_check_contents("Part 2 of 3");
    $wth->browser_submit_form(form_name => 'newpetition',
            fields => {
                name => name_n(99),
                organisation => "Society for the Advancement of Effective Petitioning",
                address => "The Beseechment Building, Importuning Island",
                postcode => "SW1A 2AA",
                telephone => "01234 56789",
                org_url => "http://www.petitionsrock.org.uk",
                email => email_n(99),
                email2 => email_n(99)
                }, button => 'tosteppreview') or die "Failed to submit step 2";

    $wth->browser_check_contents("Part 3 of 3");
    $wth->browser_submit_form(form_name => 'newpetition',
            fields => { }, button => 'tocreate') or die "Failed to submit step 3";

    $wth->browser_check_contents("We have sent you an email to confirm");
    call_send_messages();
    my $confirm_email = $wth->email_get_containing('%Subject: Confirm your new petition%To: '.email_n(99).  '%');
    die "Confirm petition email link not found\n" if ($confirm_email !~ m#^\s*(http://.*$)#m);
    my $confirm_petition_link = $1;

    print $confirm_petition_link;

=comment
    # Confirm email
    my $confirmation_email = $wth->email_get_containing(
        '%To: '.email_n(1).'%%');
    die "Pledge confirmation link not found\n" if ($confirmation_email !~ m#^\s+(http://.*$)#m);
    my $confirmation_url = $1;
    $wth->email_check_url($confirmation_url);
    print "Confirmation URL: " . $confirmation_url . "\n" if $verbose > 1;
    $wth->browser_get($confirmation_url);
    $wth->browser_check_contents("You're the 1st person to sign up to get emails"); 
=cut
}

#############################################################################


