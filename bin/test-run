#!/usr/bin/perl -w -I../../perllib
#
# test-run:
# Test harness for petitions.  Makes sure we haven't broken the code.
# 
# Requires:
# * ../general/conf file set up for petitions, and matching the below requirements
# * apache configured to serve ../web on OPTION_BASE_URL
# * a petitions database with name ending "_testharness"; this script will drop and remake 
#   the database, so make sure it is never used for anything important
# * email addresses (email_n below) configured to pipe to ./test-mailin with fast
#   local delivery, and
#
# Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
# Email: francis@mysociety.org; WWW: http://www.mysociety.org/
#

# Things to add:
#    - Reject petition, for various reasons
#    - Resubmit rejected petition
#    - Stuff to do with writing/sending the government response
#    - Check rejected petitions in the relevant categories can/can't be seen on the site?
#    - Confirm a signer through the admin interface
#    - Remove signer
#    - Various RSS feeds

my $rcsid = ''; $rcsid .= '$Id: test-run,v 1.15 2006-10-16 16:46:25 francis Exp $';

use strict;
require 5.8.0;

use mySociety::Util;
use mySociety::Config;
mySociety::Config::set_file('../conf/general');
use mySociety::DBHandle qw(dbh);
use mySociety::WebTestHarness;

use Data::Dumper;
use Carp qw(verbose);
use Storable;
use FindBin;
use Getopt::Long;
use IO::Handle;
use POSIX;

sub help {
print <<END

Usage: test-run [OPTION}

Options are
    --verbose=n   Choose 0 (no progress), 1 (basic actions), 2 (full debug)

END
}

# Parse command line
our $verbose = 0; # currently 3 levels: 0, 1 and 2
our $multispawn = 1; # can test launching multiple instances of cron jobs
our $help;
if (!GetOptions(
        'verbose=i' =>  \$verbose,
        'help' =>               \$help
    )) {
    help();
    exit(1);
}
if ($help) {
    help();
    exit(0);
}

# Set up options
our $base_url = mySociety::Config::get('BASE_URL');
our $admin_url = mySociety::Config::get('ADMIN_URL');
our $auth_user = mySociety::Config::get('AUTH_USER');
our $auth_password = mySociety::Config::get('AUTH_PASSWORD');
our $httpd_error_log = mySociety::Config::get('HTTPD_ERROR_LOG');
our $email_domain = mySociety::Config::get('EMAIL_DOMAIN');
our $web_domain = mySociety::Config::get('WEB_DOMAIN');
our $contact_email = mySociety::Config::get('CONTACT_EMAIL');
our $test_email_prefix = mySociety::Config::get('TEST_EMAIL_PREFIX');
sub email_n { my $n = shift; return "$test_email_prefix+$n\@$email_domain"; }
sub name_n { my $n = shift; return "Persephone Petitioner $n"; }

#############################################################################
# Main code

# Kill FastCGI processes
# XXX The processes respawn from SIGTERM, and SIGKILL seems to confuse Apache.
# Any way of doing this without needing root access to "apachectl graceful"?
#mySociety::Util::kill_named_processes(SIGTERM, '"^(ref-index.cgi|ref-sign.cgi|php4-cgi)\$"');

# Configure test harness class
print "Set up web test harness...\n" if $verbose > 0;
our $wth = new mySociety::WebTestHarness();
$base_url =~ m#^http://(.+)/?$#;
$wth->browser_credentials("$1:80", "ePetitions staging site", $auth_user, $auth_password); 
$wth->browser_credentials("$1:80", "$web_domain admin pages", $auth_user, $auth_password); 
$wth->database_connect('PET_');
$wth->database_drop_reload('../db/schema.sql');
$wth->database_cycle_sequences(200);
$wth->log_watcher_setup($httpd_error_log);
$wth->log_watcher_self_test($base_url . "/test.php?error=1", "deliberate_error_to_test_error_handling");
my $eveld_bin = "$FindBin::Bin/../../services/EvEl/bin/eveld";
$eveld_bin = undef if ! -e $eveld_bin; # when running on servers rely on EvEl daemon, rather than calling EvEl binary directly XXX need more explicit way of distinguishing this case, than just checking evel isn't checked out in the same tree
$wth->email_setup({ eveld_bin => $eveld_bin,
                    log_mailbox => "log_mailbox" });
$wth->browser_set_validator("/usr/bin/validate");

# Start email and signup daemons
my $petemaild_pid;
my $petsignupd_pid;
END {
    # When script exits, get the email and signup daemons to gracefully shutdown
    kill(POSIX::SIGHUP, $petemaild_pid) if $petemaild_pid;
    kill(POSIX::SIGHUP, $petsignupd_pid) if $petsignupd_pid;
    # Wait for all children to have exited
    while (1) {
        my $wait_pid = wait();
        last if ($wait_pid == -1);
    }
};
print "Starting daemons...\n" if $verbose > 0;
$petemaild_pid = fork();
die "failed to fork" if (!defined($petemaild_pid));
if ($petemaild_pid == 0) {
    exec("./petemaild", "--debug", "--verbose=0");
    exit;
}
$petsignupd_pid = fork();
die "failed to fork" if (!defined($petsignupd_pid));
if ($petsignupd_pid == 0) {
    exec("./petsignupd", "--debug");
    exit;
}

# Syntax check all .php files
print "Syntax check all PHP files...\n" if $verbose > 0;
$wth->php_check_syntax("../../pet/");
$wth->php_check_syntax("../../pet/templates/emails/", qr//);

print "Basic test...\n" if $verbose > 0;
do_basic_test();

# Check for any unhandled mails or errors
#call_fyrqd();
print "Checking no emails left at end...\n" if $verbose > 1;
$wth->email_check_none_left();
print "Checking no log file errors at end...\n" if $verbose > 1;
$wth->log_watcher_check();
print "Everything completed successfully\n";

#############################################################################
# General functions

# Change the date that all parts of ePetitions think is today.  Call with no
# parameters to reset it to the actual today.
sub set_pet_date {
    my $new_date = shift;
    if (defined($new_date)) {
        dbh()->do('delete from debugdate; insert into debugdate (override_today) values (?);', {}, $new_date);
    } else {
        dbh()->do('delete from debugdate;');
    }
    dbh()->commit();
}

# Call fyrqd for one pass
#sub call_fyrqd {
#    system("./fyrqd", "--debug", "--once", "--email", # $verbose > 1 ? qw(--verbose) : ()
#        ) and die "Failed to call fyrqd";
#}

# Call send messages cron job
sub call_send_messages {
     $wth->multi_spawn($multispawn, "php send-messages " . ($verbose > 1 ? qw(--verbose) : ''), $verbose);
}

# Call mark finished cron job
sub call_mark_finished {
     $wth->multi_spawn($multispawn, "php mark-finished " . ($verbose > 1 ? qw(--verbose) : ''), $verbose);
}

#############################################################################

sub do_basic_test {
    set_pet_date('1988-08-08');

    my $petition_text = "take action on every petition on this site with more than 1000 signers";

    # Check front page works
    $wth->browser_get($base_url);
    $wth->browser_check_contents("Petitions");
    $wth->browser_check_no_contents("0 signatures");

    # Create a new petition
    $wth->browser_follow_link(text_regex => qr/Create a Petition/);
    $wth->browser_check_contents("Part 1 of 3");
    $wth->browser_submit_form(form_name => 'newpetition',
            fields => {
                pet_content => $petition_text,
                detail => "I think it is very important that the Prime Minister takes all petitions seriously. He should be compelled to do anything that more than 1000 people sign, as this would be good for democracy and not at all exploitable by small groups of people.\n\nMy favourite thing about this petition is that it has two paragraphs of text in the description. That rocks!",
                rawdeadline => 'Dec 31st',
                ref => 'onethousand'
                }, button => 'tostepyou') or die "Failed to submit step 1";

    $wth->browser_check_contents("Part 2 of 3");
    $wth->browser_submit_form(form_name => 'newpetition',
            fields => {
                name => name_n(99),
                organisation => "Society for the Advancement of Effective Petitioning",
                address => "The Beseechment Building\nImportuning Island",
                postcode => "SW1A 2AA",
                telephone => "01234 56789",
                org_url => "http://www.petitionsrock.org.uk",
                email => email_n(99),
                email2 => email_n(99)
                }, button => 'tosteppreview') or die "Failed to submit step 2";

    $wth->browser_check_contents("Part 3 of 3");
    $wth->browser_submit_form(form_name => 'newpetition',
            fields => { }, button => 'tocreate') or die "Failed to submit step 3";

    $wth->browser_check_contents("We have sent you an email to confirm");

    # Confirm petition
    my $confirm_email = $wth->email_get_containing('%Subject: Confirm your new petition%To: "'.name_n(99).'" <'.email_n(99).'>%');
    die "Confirm petition email link not found\n" if ($confirm_email !~ m#^\s*(https?://.*$)#m);
    my $confirm_petition_link = $1;
    print "Confirmation link: $confirm_petition_link\n" if $verbose > 1;
    $wth->browser_get($confirm_petition_link);
    $wth->browser_check_contents("Thank you for creating your petition");
    $wth->browser_check_contents("It has been entered on our system");

    # Get the email to the administrator
    call_send_messages();
    my $admin_approve_email = $wth->email_get_containing('%Subject: New petition to the Prime Minister%To: '.$contact_email.'%');
    die "Admin approve email link not found\n" if ($admin_approve_email !~ m#^\s*(http://.*$)#m);
    my $admin_approve_link = $1;
    print "Admin approve link: $admin_approve_link\n" if $verbose > 1;

    # Follow link to admin page
    $wth->browser_get($admin_approve_link);
    $wth->browser_check_contents("Petitions and Signers");
    $wth->browser_check_contents($petition_text);
    $wth->email_check_none_left();
    call_send_messages();
    $wth->browser_submit_form(form_name => 'petition_admin_approve',
            fields => { }, button => 'approve') or die "Failed to submit approve petition button";
    call_send_messages();
    #my $admin_approve_email = $wth->email_get_containing('%Subject: New petition to the Prime Minister%To: '.$contact_email.'%');
    $wth->browser_check_contents('Petition approved!');

    # Check that petition is on the front page, and has its own page
    $wth->browser_get($base_url);
    $wth->browser_check_contents($petition_text);
    $wth->browser_check_contents("0 signatures");
    $wth->browser_follow_link(text_regex => qr/$petition_text/);
    $wth->browser_check_contents($petition_text);
    $wth->browser_check_contents("31 December 1988");

    # Loop through several signers
    my $c = 0;
    foreach my $signer_no (1488..1490) {
        my $uri = $wth->browser_uri();

        # Sign the petition
        $wth->browser_submit_form(form_name => 'signForm',
                fields => {
                    name => name_n($signer_no),
                    email => email_n($signer_no),
                    email2 => email_n($signer_no),
                    address => "$signer_no Signature Street\n\nSealville",
                    postcode => "EH99 1SP",
                    }, button => 'submit') or die "Failed to submit sign petition";
        $wth->browser_check_contents("We've sent you an email");

        # Confirm signature
        my $confirm_signature_email = $wth->email_get_containing('%Subject: Signing up to ask the Prime Minister%To: "'.name_n($signer_no).'" <'.email_n($signer_no).'>%Please click on the link below to confirm your signature%');
        die "Confirm signature email link not found\n" if ($confirm_signature_email !~ m#^\s*(https?://.*$)#m);
        my $confirm_signature_link = $1;
        print "Confirmation link: $confirm_signature_link\n" if $verbose > 1;
        $wth->browser_get($confirm_signature_link);
        $wth->browser_check_contents("Thank you, you're now signed up to this petition!");

        # Check it says it is signed on the front page
        $wth->browser_get($base_url);
        $wth->browser_check_contents($petition_text);
        $c++;
        $wth->browser_check_contents("$c signature");

        $wth->browser_get($uri);
    }

    # Go forward in time to day that deadline expires at end of, and
    # make sure that nothing happens.
    set_pet_date('1988-12-31');
    call_mark_finished();
    $wth->browser_get($base_url);
    $wth->browser_check_contents($petition_text);
    $wth->email_check_none_left();

    # And one more day, check pledge is marked as finished
    set_pet_date('1989-01-01');
    call_mark_finished();
    # XXX probably should be a "your pledge has finished" mail here
    $wth->browser_get($base_url);
    $wth->browser_check_no_contents($petition_text);
    $wth->browser_check_contents("None");
    $wth->browser_follow_link(text_regex => qr/View petitions/);
    $wth->browser_check_no_contents($petition_text);
    $wth->browser_follow_link(text_regex => qr/Closed petitions/);
    $wth->browser_check_contents($petition_text);
    $wth->browser_follow_link(text_regex => qr/$petition_text/);
    $wth->browser_check_contents("This petition is now closed");

}

#############################################################################


