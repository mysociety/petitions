#!/usr/bin/perl -w
#
# petsignupd:
# Back-end signup service for petitions site.
#
# Clients -- the web scripts on the front-end servers -- send signup details to
# us in UDP packets. On receipt of such a packet we write a row to the
# database, but do not commit it immediately. Instead we set an alarm for a
# short interval in the future. Any more packets that arrive before the alarm
# fires also result in writes to the database; when the alarm fires, we commit
# them all and acknowledge them to the senders.
#
# The idea here is that a commit of ten inserts takes about as long as a commit
# of one insert, so we can improve throughput by batching inserts. That's very
# inconvenient in the front-end scripts, because it means they'd have to share
# database handles, but is easy with a coordinating daemon. If the daemon fails
# or the packets don't get through, then the web scripts can sign up in the
# usual way.
#
# Copyright (c) 2006 UK Citizens Online Democracy. All rights reserved.
# Email: chris@mysociety.org; WWW: http://www.mysociety.org/
# 
#

my $rcsid = ''; $rcsid .= '$Id: petsignupd,v 1.4 2006-08-01 20:56:43 chris Exp $';

use strict;

# Horrible boilerplate to set up appropriate library paths.
use FindBin;
use lib "$FindBin::Bin/../perllib";
use lib "$FindBin::Bin/../../perllib";

use mySociety::Config;
BEGIN {
    mySociety::Config::set_file("$FindBin::Bin/../conf/general");
}

use Carp;
use Errno;
use Error qw(:try);
use IO::Select;
use IO::Socket;
use Socket;
use Tie::Cache;
use Time::HiRes qw(time alarm);

use mySociety::DBHandle qw(dbh);

use Petitions;
use Petitions::RPC;

# Maximum (ideal) interval from signup request to commit.
#use constant MAX_SIGNUP_TIME    => 0.25;    # seconds
use constant MAX_SIGNUP_TIME    => 0.25;    # seconds

my $s = new IO::Socket::INET(
                    LocalAddr => '0.0.0.0',
                    LocalPort => mySociety::Config::get('RPC_SERVER_PORT'),
                    Type => SOCK_DGRAM,
                    Proto => 'udp',
                    ReuseAddr => 1,
                    Blocking => 0) or die "socket: $!";

my $foad = 0;
$SIG{TERM} = sub { $foad = 1; };

my $alarm_pending = 0;
my $alarm_fired = 0;
$SIG{ALRM} = sub { $alarm_fired = 1; $alarm_pending = 0; };

# Cache signups we've seen so that we can avoid round trips to the database
# when a packet is lost and the client resends.
my %signercache;
tie(%signercache, 'Tie::Cache', { MaxCount => 10000, Debug => 0 });

my %pending = ( );
sub acknowledge_pending () {
    $s->blocking(1);
    foreach my $r (values(%pending)) {
        my $packet = Petitions::RPC::make_ack_packet($r->{cookie});
        if (!$s->send($packet, 0, $r->{client})) {
            my ($port, $ip) = sockaddr_in($r->{client});
            print STDERR "sending to $ip:$port: $!\n";
        }
    }
    $s->blocking(0);
    %pending = ( );
}

my $inlock = 0;
while (!$foad) {
    my $buf = '';
    my $sender;
    my @ready = IO::Select->new($s)->can_read(MAX_SIGNUP_TIME / 10);
    if (@ready) {
        while (defined($sender = $s->recv($buf, 65536, 0))) {
            if (my $r = Petitions::RPC::parse_packet($buf)) {
                # We have a valid signup packet. Schedule an alarm so that we will
                # send a response within the deadline.
                if (!$alarm_pending) {
                    $alarm_pending = 1;
                    alarm(MAX_SIGNUP_TIME);
                }
                # Record address to which we send acknowledgement.
                $r->{client} = $sender;
                if (!exists($signercache{"$r->{ref}\0$r->{email}"})) {
                    # Attempt the insert, detecting any error which occurs.
                    try {
                        if (!$inlock) {
                            dbh()->do('lock table signer in row exclusive mode')
                            $inlock = 1;
                        }
                        Petitions::RPC::sign_petition_db($r);
                        $signercache{"$r->{ref}\0$r->{email}"} = 1;
                        $pending{$r->{cookie}} = $r;
                    } catch mySociety::DBHandle::Error with {
                        my $E = shift;
                        print STDERR "attempt to sign $r->{email} up to $r->{ref} failed; DB error: ", $E->text(), "\n";
                    };
                } else {
                    $pending{$r->{cookie}} = $r;
                }
                # Done handling this request.
            } else {
                # Invalid packet of some sort. Log and continue.
                my ($port, $ip) = sockaddr_in($r->{sender});
                print STDERR "bad packet from $ip:$port\n";
            }
        }
        
        if (!$!{EAGAIN}) {
            print STDERR "recvfrom: $!\n";
        }
    }

    # If the alarm has fired, then commit the transaction and send
    # acknowledgements to the clients.
    if ($alarm_fired && keys(%pending)) {
        try {
            print STDERR "committing rows\n";
            dbh()->commit();
            $inlock = 0;
            acknowledge_pending();
            $alarm_fired = 0;
        } catch mySociety::DBHandle::Error with {
            my $E = shift;
            print STDERR "committing ", scalar(keys(%pending)), " requests failed; DB error: ", $E->text(), "\n";
        };
    }
}

if (keys(%pending)) {
    try {
        dbh()->commit();
        acknowledge_pending();
    } catch mySociety::DBHandle::Error with {
        my $E = shift;
        print STDERR "committing ", scalar(keys(%pending)), " requests failed (at shutdown); DB error: ", $E->text(), "\n";
    };
}

untie(%signercache);
